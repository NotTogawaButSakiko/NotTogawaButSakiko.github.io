<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Sakiko&#39;s Blog</title>
    <link>http://nottogawabutsakiko.github.io/</link>
    
    <atom:link href="http://nottogawabutsakiko.github.io/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>弱い私はもう死にました。</description>
    <pubDate>Sun, 08 Sep 2024 09:08:58 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>时间复杂度</title>
      <link>http://nottogawabutsakiko.github.io/%E7%AC%94%E8%AE%B0/complicity/</link>
      <guid>http://nottogawabutsakiko.github.io/%E7%AC%94%E8%AE%B0/complicity/</guid>
      <pubDate>Sat, 07 Sep 2024 03:50:20 GMT</pubDate>
      
      <description>&lt;p&gt;一个算法中的语句最坏情况下执行次数称为 &lt;strong&gt;语句频度&lt;/strong&gt; 或 &lt;strong&gt;时间频度&lt;/strong&gt; 记为 $T(n)$.&lt;/p&gt;
&lt;p&gt;然而, 当输入规模足够大, 我们便不用确定算法的精确运行次数, 只需要考虑算法的增长量级即可, 因此我们要研究算法的 &lt;strong&gt;渐进&lt;/strong&gt; 效率.&lt;/p&gt;
&lt;p&gt;若存在 $f(n)$ ,使 $&#92;lim &#92;limits_{n -&amp;gt; &#92;infty} &#92;frac{T(n)}{f(n)}$ 为不等于零的常数, 则称 $f(n)$ 为 $T(n)$ 的 &lt;strong&gt;同数量级(阶)函数&lt;/strong&gt; ,记作:&lt;/p&gt;
&lt;p&gt;$$T(n) &amp;#x3D; F(f(n))$$&lt;/p&gt;
&lt;p&gt;则称 $F(f(n))$ 为算法 $T(n)$ 的 &lt;strong&gt;渐进时间复杂度&lt;/strong&gt;, 简称 &lt;strong&gt;时间复杂度&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;这里的 $F$ , 就是 &lt;strong&gt;渐进符号&lt;/strong&gt; &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这里的 $T(n) &amp;#x3D; F(f(n))$ 中的 $&amp;#x3D;$ 实际并不准确. 正常来说应当是 $T(n) ∈ F(f(n))$ , 即 $T(n)$ 是 $F(f(n))$ 的一个元素.为了方便描述, 我们约定 $T(n) &amp;#x3D; F(f(n))$ 表达相同的概念. 后文相同.&lt;/p&gt;
&lt;/blockquote&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>一个算法中的语句最坏情况下执行次数称为 <strong>语句频度</strong> 或 <strong>时间频度</strong> 记为 $T(n)$.</p><p>然而, 当输入规模足够大, 我们便不用确定算法的精确运行次数, 只需要考虑算法的增长量级即可, 因此我们要研究算法的 <strong>渐进</strong> 效率.</p><p>若存在 $f(n)$ ,使 $\lim \limits_{n -&gt; \infty} \frac{T(n)}{f(n)}$ 为不等于零的常数, 则称 $f(n)$ 为 $T(n)$ 的 <strong>同数量级(阶)函数</strong> ,记作:</p><p>$$T(n) &#x3D; F(f(n))$$</p><p>则称 $F(f(n))$ 为算法 $T(n)$ 的 <strong>渐进时间复杂度</strong>, 简称 <strong>时间复杂度</strong>.</p><p>这里的 $F$ , 就是 <strong>渐进符号</strong> </p><blockquote><p>这里的 $T(n) &#x3D; F(f(n))$ 中的 $&#x3D;$ 实际并不准确. 正常来说应当是 $T(n) ∈ F(f(n))$ , 即 $T(n)$ 是 $F(f(n))$ 的一个元素.为了方便描述, 我们约定 $T(n) &#x3D; F(f(n))$ 表达相同的概念. 后文相同.</p></blockquote><span id="more"></span><h1 id="计算同阶函数-证明略"><a href="#计算同阶函数-证明略" class="headerlink" title="计算同阶函数 (证明略)"></a>计算同阶函数 (证明略)</h1><ol><li>省略常数项和常数系数</li><li>对于对数, 省略底数, 用 $log$ 表示</li></ol><h1 id="渐进符号"><a href="#渐进符号" class="headerlink" title="渐进符号"></a>渐进符号</h1><p>注意, 这里的函数均 <strong>渐进非负</strong> , 即 $f(n)$ 和 $g(n)$ 的值非负.</p><p>方便记忆的是, 大写符号为 <strong>非严格包含</strong> (含等于), 小写符号为 <strong>严格包含</strong> (不含等于)</p><p>注意的是小写渐进符号是 <strong>不一定</strong> 渐进紧确的, 也就是说 $\lim \limits_{n -&gt; \infty} \frac{T(n)}{f(n)}$ 可以为 $0(o)$ 或 $\infty(ω)$.</p><p>这里省去单独对小写渐进符号的描述.</p><h2 id="Θ-记号-渐进紧确界"><a href="#Θ-记号-渐进紧确界" class="headerlink" title="$Θ$ 记号 (渐进紧确界)"></a>$Θ$ 记号 (渐进紧确界)</h2><p>对于函数 $f(n)$ 和 $g(n)$ , $f(n)&#x3D;Θ(g(n))$ , 当且仅当 $\exists c_1, c_2,n_0&gt;0$,使得 $\forall n ≥ n_0,0≤ c_1·g(n) ≤ f(n) ≤ c_2 · g(n)$ .</p><p>也就是说, 如果函数 $f(n)&#x3D;Θ(g(n))$ ,那么我们能找到两个正数 $c_1,c_2$ 使得 $f(n)$ 被 $c_1·g(n)$ 和 $c_2·g(n)$ 夹在中间. 我们称 $g(n)$ 为 $f(n)$ 的 <strong>渐进紧确界</strong></p><h2 id="O-记号-渐进紧确上界"><a href="#O-记号-渐进紧确上界" class="headerlink" title="$O$ 记号 (渐进紧确上界)"></a>$O$ 记号 (渐进紧确上界)</h2><p>对于函数 $f(n)$ 和 $g(n)$,$f(n)&#x3D;O(g(n))$ ,当且仅当 $\exists c,n_0&gt;0$使得 $\forall n ≥ n_0,0 ≤ f(n) ≤ c · g(n)$.</p><p>也就是说,如果函数 $f(n)&#x3D;O(g(n))$,那么我们能找到一个正数 $c$ 使得 $f(n)$ 在 $c·g(n)$  下面. 我们称 $g(n)$ 为 $f(n)$ 的 <strong>渐进紧确上界</strong></p><h2 id="Ω-记号-渐进紧确下界"><a href="#Ω-记号-渐进紧确下界" class="headerlink" title="$Ω$ 记号 (渐进紧确下界)"></a>$Ω$ 记号 (渐进紧确下界)</h2><p>对于函数 $f(n)$ 和 $g(n)$, $f(n)&#x3D;Ω(g(n))$,当且仅当 $\exists c,n_0&gt;0$,使得 $\forall n ≥ n_0,0 ≤ c · g(n) ≤ f(n)$. </p><p>也就是说,如果函数 $f(n)&#x3D;Ω(g(n))$,那么我们能找到一个正数 $c$ 使得 $f(n)$ 在 $c·g(n)$  上面. 我们称 $g(n)$ 为 $f(n)$ 的 <strong>渐进紧确下界</strong></p><h1 id="主定理-M定理"><a href="#主定理-M定理" class="headerlink" title="主定理 (M定理)"></a>主定理 (M定理)</h1><p>主定理为用来计算递归时间复杂度的定理 $Master Theorem$</p><p>假设我们用递归递推式$$T(n) &#x3D; aT(\frac{n}{b})+f(n)$$</p><p>其中 $a$ 为递归子问题的数量,$\frac{n}{b}$ 为每个子问题的规模,$f(n)$ 为分解和合并的时间.</p><p> 那么就会有三种情况:</p><p> <img data-src="/Mtherom.jpg" alt="M 定理"></p><ul><li>当 $f(n)$ 比 $n^{log_ba}$ 小时,$T(n) &#x3D; Θ(n^{log_ba})$</li><li>当 $f(n)$ 趋近于 $n^{log_ba}$ 时,$T(n) &#x3D; Θ(n^{log_ba}logn)$</li><li>当 $f(n)$ 比 $n^{log_ba}$ 大时,$T(n) &#x3D; Θ(f(n))$</li></ul><p>二分查找的时间复杂度:<br>$$T(n) &#x3D; T(\frac{n}{2}) + O(1) &#x3D; Θ(logn)$$</p><p>归并排序的时间复杂度:<br>$$T(n) &#x3D; 2T(\frac{n}{2}) + O(n) &#x3D; Θ(nlogn)$$</p><p>二叉树遍历的时间复杂度:<br>$$T(n) &#x3D; 2T(\frac{n}{2}) + O(1) &#x3D; Θ(n)$$</p><h1 id="时间复杂度类型"><a href="#时间复杂度类型" class="headerlink" title="时间复杂度类型"></a>时间复杂度类型</h1><p>通常情况下,我们所考虑的时间复杂度普遍指最坏时间复杂度,这也是最常用的时间复杂度,能够适用绝大多数情况.</p><p>但是对于一些特殊情况,我们并不能单单关注最坏时间复杂度.</p><h2 id="平均-期望-复杂度"><a href="#平均-期望-复杂度" class="headerlink" title="平均 (期望) 复杂度"></a>平均 (期望) 复杂度</h2><p>指的是输入数据 <strong>随机</strong> 的情况下期望的时间复杂度.</p><h2 id="均摊复杂度"><a href="#均摊复杂度" class="headerlink" title="均摊复杂度"></a>均摊复杂度</h2><p>在我们进行数据结构操作时,经常会对数据进行修改.因此一些看似单次复杂度高的算法,实际上所有操作均摊下来复杂度实际上并不高.因此我们并不能简单地分析最坏复杂度,而是需要均摊复杂度进行分析.</p><p>而均摊复杂度和平均(期望)复杂度的区别在于前者并不引入概率,是表示最坏情况下的所有操作的复杂度,而后者是指平均情况下的复杂度.</p><p>而计算均摊复杂度的算法就叫 <strong>摊还分析</strong>.</p><h3 id="摊还分析"><a href="#摊还分析" class="headerlink" title="摊还分析"></a>摊还分析</h3><h4 id="1-聚合法"><a href="#1-聚合法" class="headerlink" title="1.聚合法"></a>1.聚合法</h4><p>聚合分析,我们证明对所有的 $n$ ,单次最坏复杂度为 $T(n)$ ,则均摊复杂度为 $\frac{T(n)}{n}$</p><h5 id="例1-1-栈操作"><a href="#例1-1-栈操作" class="headerlink" title="例1.1:  栈操作"></a>例1.1:  栈操作</h5><p>我们假设一个栈的大小为 $k$ ,定义 <code>multipop(s)</code> 为弹出栈顶 $\min(s,k)$ 个元素.单次最坏情况显然为 $O(k)$ .但不可能每次操作都是最坏情况,事实上仅有进行 $n$ 次 <code>push</code> 操作后才能进行一次 $O(n)$ 的 <code>multipop</code>, 所以总均摊复杂度为 $O(n)$</p><h5 id="例1-2-二进制计数器递增"><a href="#例1-2-二进制计数器递增" class="headerlink" title="例1.2: 二进制计数器递增"></a>例1.2: 二进制计数器递增</h5><p>对于一个 $k$ 位初始位 0 的二进制数,我们使用 $INCREMENT$ 算法每次对这个二进制数加一.伪代码如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">i = 0</span><br><span class="line">   while i &lt; A.length and A[i] == 1</span><br><span class="line">       A[i] = 0</span><br><span class="line">       i = i+1</span><br><span class="line">   if i &lt; A.length</span><br><span class="line">       A[i] = 1</span><br></pre></td></tr></table></figure><p>显然对于连续 $k$ 个 1 的二进制数的单次操作复杂度为 $O(k)$ .但整体复杂度却不为 $O(nk)$ ,因为每一次不可能都为连续的 1, 事实上对于第 $i$ 位来说一共被操作 $\lfloor{\frac{n}{2^i}}\rfloor$ 次,所以总均摊复杂度为:</p><p>$$\sum \limits_{i&#x3D;0}^{k-1} \lfloor{\frac{n}{2^i}}\rfloor &lt; n\sum \limits_{i&#x3D;0}^{\infty} \lfloor{\frac{1}{2^i}}\rfloor &#x3D; 2n$$</p><p>因此总均摊复杂度为 $O(n)$</p><h4 id="核操作"><a href="#核操作" class="headerlink" title="核操作"></a>核操作</h4><p>我们对所有的操作赋予不同的费用,一些可能会大于或小于实际费用.这个费用我们称作 <strong>摊还代价</strong>.</p><p>当摊还代价大于实际代价时,我们将多出的差价称作信用存储起来.后续当摊还代价小于实际代价时,我们用存储的信用偿还.</p><h5 id="例2-1-栈操作"><a href="#例2-1-栈操作" class="headerlink" title="例2.1 栈操作"></a>例2.1 栈操作</h5><table><thead><tr><th>操作</th><th>实际费用</th><th>摊还代价</th></tr></thead><tbody><tr><td><code>push</code></td><td>1</td><td>2</td></tr><tr><td><code>pop</code></td><td>1</td><td>0</td></tr><tr><td><code>multipop</code></td><td>$\min(s,k)$</td><td>0</td></tr></tbody></table><p>在每次 <code>push</code> 中,我们能存入一点信用.而 <code>pop</code> 和 <code>multipop</code> 的次数显然不能超出栈中的元素数量,因此我们可以保证 <strong>任何时刻信用价值非负</strong></p><p>显然可以看出总均摊复杂度为 $O(n)$</p><h5 id="例2-2-二进制计数器递增"><a href="#例2-2-二进制计数器递增" class="headerlink" title="例2.2 二进制计数器递增"></a>例2.2 二进制计数器递增</h5><p>我们将 0 变为 1 的置位操作赋予 2 摊还代价,1 变为 0 的复位操作赋予 0 摊还代价.</p><p>由于每次会保证只有 1 次置位操作,而复位操作都可以用先前的信用偿还,因此可以保证 <strong>任何时候信用价值非负</strong></p><p>因此总均摊复杂度为 $O(n)$</p><h4 id="势能法"><a href="#势能法" class="headerlink" title="势能法"></a>势能法</h4><p>与核算法不同,势能法将预付代价描述为 <strong>势能</strong>, 释放势能可以支付未来的代价, 将势能与整个数据结构相联系而不是特定对象.</p><p>我们设第 $i$ 次操作的费用为 $c_i$ ,设第 $i$ 次操作后的数据状态为 $D_i$  ,初始状态为 $D_0$, 设摊还代价为 $c_i^{\prime}$ ,我们选取一个从数据结构的状态映射到势的函数 $F$ ,我们需要保证对于任意 $i$ , $F(D_i) \geq F(D_0)$ .</p><p>令 $c_i^{\prime} &#x3D; c_i + F(D[i]) - F(D[i-1])$ ,显然 $\sum \limits_{i&#x3D;1}^{n} c_i^{\prime} &#x3D; \sum \limits_{i&#x3D;1}^{n} c_i + F(D_n) - F(D_0)$ , 由于 $F(D_n) \geq F(D_0)$ ,所以 $\sum c_i^{\prime} \geq \sum c_i$ ,则 $\sum c_i^{\prime}$ 为总摊还复杂度的上界</p><h5 id="例3-1-栈操作"><a href="#例3-1-栈操作" class="headerlink" title="例3.1 栈操作"></a>例3.1 栈操作</h5><p>我们选取栈中元素个数为势能函数 $F$ .</p><p>对于 <code>push</code> 操作, 实际代价为 1, 势差为1, 摊还代价为2;</p><p>对于 <code>pop</code> 操作, 实际代价为1, 势差为-1, 摊还代价为0;</p><p>对于 <code>multipop</code> 操作, 实际代价为 $\min(s,k)$ ,势差同样为 $\min(s,k)$ ,摊还代价为0</p><p>因此总均摊复杂度为 $O(n)$</p><h5 id="例3-2-二进制计数器递增"><a href="#例3-2-二进制计数器递增" class="headerlink" title="例3.2 二进制计数器递增"></a>例3.2 二进制计数器递增</h5><p>我们设 1 的个数为势能函数 $F$</p><p>每次操作实际代价为 $k$, 势差为 $2-k$, 摊还代价为 $2$</p><p>则总摊还复杂度为 $O(n)$</p><hr><p>我们发现,以上三种摊还分析方法的本质其实是一样的,即 <strong>摊还</strong> 思想. 这种思想尤为重要,在以后的算法学习中,我们可以经常发现这种思想的身影.</p>]]></content:encoded>
      
      
      <category domain="http://nottogawabutsakiko.github.io/categories/%E7%AC%94%E8%AE%B0/">笔记</category>
      
      
      <category domain="http://nottogawabutsakiko.github.io/tags/%E7%AE%97%E6%B3%95/">算法</category>
      
      
      <comments>http://nottogawabutsakiko.github.io/%E7%AC%94%E8%AE%B0/complicity/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
