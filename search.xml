<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>时间复杂度</title>
    <url>/%E7%AC%94%E8%AE%B0/%E5%A4%8D%E6%9D%82%E5%BA%A6/</url>
    <content><![CDATA[<p>一个算法中的语句 <strong>执行次数</strong> 称为语句频度或时间频度，记为 $T(n)$；</p>
<p>若存在 $f(n)$ ,使 $\lim \limits_{n -&gt; \infty} \frac{T(n)}{f(n)}$ 为不等于零的常数，则称 $f(n)$ 为 $T(n)$ 的 <strong>同数量级(阶)函数</strong>，记作</p>
<p>$$T(n) &#x3D; O(f(n))$$</p>
<p>则称 $O(f(n))$ 为算法 $T(n)$ 的 <strong>渐进时间复杂度</strong>，简称 <strong>时间复杂度</strong>。</p>
<span id="more"></span>

<h1 id="计算-f-n"><a href="#计算-f-n" class="headerlink" title="计算 f(n)"></a>计算 f(n)</h1><ol>
<li>取最大的项</li>
<li>省略掉所有的<strong>常数系数</strong>、<strong>常数底数</strong>、<strong>常数项</strong></li>
</ol>
<h1 id="渐进符号"><a href="#渐进符号" class="headerlink" title="渐进符号"></a>渐进符号</h1><h2 id="Θ-记号（渐进紧确界）"><a href="#Θ-记号（渐进紧确界）" class="headerlink" title="$Θ$记号（渐进紧确界）"></a>$Θ$记号（渐进紧确界）</h2><p>对于函数 $f(n)$ 和 $g(n)$，$f(n)&#x3D;Θ(g(n))$，当且仅当 $\exists c_1, c_2,n_0&gt;0$，使得 $\forall n ≥ n_0,0≤ c_1·g(n) ≤ f(n) ≤ c_2 · g(n)$。</p>
<p>也就是说，如果函数 $f(n)&#x3D;Θ(g(n))$，那么我们能找到两个正数 $c_1,c_2$ 使得 $f(n)$ 被 $c_1·g(n)$ 和 $c_2·g(n)$ 夹在中间。</p>
<h2 id="O-记号（渐进紧确上界）"><a href="#O-记号（渐进紧确上界）" class="headerlink" title="$O$ 记号（渐进紧确上界）"></a>$O$ 记号（渐进紧确上界）</h2><p>对于函数 $f(n)$ 和 $g(n)$，$f(n)&#x3D;Θ(g(n))$，当且仅当 $\exists c,n_0&gt;0$，使得 $\forall n ≥ n_0,0 ≤ f(n) ≤ c · g(n)$。</p>
<p>也就是说，如果函数 $f(n)&#x3D;Θ(g(n))$，那么我们能找到一个正数 $c$ 使得 $f(n)$ 在 $c·g(n)$  下面。</p>
<h2 id="Ω-记号（渐进紧确下界）"><a href="#Ω-记号（渐进紧确下界）" class="headerlink" title="$Ω$记号（渐进紧确下界）"></a>$Ω$记号（渐进紧确下界）</h2><p>对于函数 $f(n)$ 和 $g(n)$，$f(n)&#x3D;Θ(g(n))$，当且仅当 $\exists c,n_0&gt;0$，使得 $\forall n ≥ n_0,0 ≤ c · g(n) ≤ f(n)$。</p>
<p>也就是说，如果函数 $f(n)&#x3D;Θ(g(n))$，那么我们能找到一个正数 $c$ 使得 $f(n)$ 在 $c·g(n)$  上面。</p>
<h1 id="主定理（M定理）"><a href="#主定理（M定理）" class="headerlink" title="主定理（M定理）"></a>主定理（M定理）</h1><p>主定理为用来计算递归时间复杂度的定理 $Master Theorem$</p>
<p>假设我们用递归递推式$$T(n) &#x3D; aT(\frac{n}{b})+f(n)$$</p>
<p>其中 $a$ 为递归子问题的数量，$\frac{n}{b}$ 为每个子问题的规模，$f(n)$ 为分解和合并的时间。</p>
<p> 那么就会有三种情况：</p>
<p> <img data-src="/image.jpg"></p>
<ul>
<li>当 $f(n)$ 比 $n^{log_ba}$ 小时，$T(n) &#x3D; Θ(n^{log_ba})$</li>
<li>当 $f(n)$ 趋近于 $n^{log_ba}$ 时，$T(n) &#x3D; Θ(n^{log_ba}logn)$</li>
<li>当 $f(n)$ 比 $n^{log_ba}$ 大时，$T(n) &#x3D; Θ(f(n))$</li>
</ul>
<h2 id="二分查找的时间复杂度"><a href="#二分查找的时间复杂度" class="headerlink" title="二分查找的时间复杂度"></a>二分查找的时间复杂度</h2><p>$$T(n) &#x3D; T(\frac{n}{2}) + O(1) &#x3D; Θ(logn)$$</p>
<h2 id="归并排序的时间复杂度"><a href="#归并排序的时间复杂度" class="headerlink" title="归并排序的时间复杂度"></a>归并排序的时间复杂度</h2><p>$$T(n) &#x3D; 2T(\frac{n}{2}) + O(n) &#x3D; Θ(nlogn)$$</p>
<h2 id="二叉树遍历的时间复杂度"><a href="#二叉树遍历的时间复杂度" class="headerlink" title="二叉树遍历的时间复杂度"></a>二叉树遍历的时间复杂度</h2><p>$$T(n) &#x3D; 2T(\frac{n}{2}) + O(1) &#x3D; Θ(n)$$</p>
<h1 id="均摊复杂度"><a href="#均摊复杂度" class="headerlink" title="均摊复杂度"></a>均摊复杂度</h1><p>在我们进行数据结构操作时,经常会对数据进行修改.因此一些看似单次复杂度高的算法,实际上所有操作均摊下来复杂度实际上并不高.因此我们并不能简单地分析最坏复杂度,而是需要均摊复杂度进行分析.</p>
<p>而均摊复杂度和平均(期望)复杂度的区别在于前者并不引入概率,是表示最坏情况下的所有操作的复杂度,而后者是指平均情况下的复杂度.</p>
<p>而计算均摊复杂度的算法就叫摊还分析.</p>
<h2 id="摊还分析"><a href="#摊还分析" class="headerlink" title="摊还分析"></a>摊还分析</h2><h3 id="1-聚合法"><a href="#1-聚合法" class="headerlink" title="1.聚合法"></a>1.聚合法</h3><p>聚合分析,我们证明对所有的 $n$ ,单次最坏复杂度为 $T(n)$ ,则均摊复杂度为 $\frac{T(n)}{n}$</p>
<h4 id="例1-1-栈操作"><a href="#例1-1-栈操作" class="headerlink" title="例1.1:  栈操作"></a>例1.1:  栈操作</h4><p>我们假设一个栈的大小为 $k$ ,定义 <code>multipop(s)</code> 为弹出栈顶 $\min(s,k)$ 个元素.单次最坏情况显然为 $O(k)$ .但不可能每次操作都是最坏情况,事实上仅有进行 $n$ 次 <code>push</code> 操作后才能进行一次 $O(n)$ 的 <code>multipop</code>, 所以总均摊复杂度为 $O(n)$</p>
<h4 id="例1-2-二进制计数器递增"><a href="#例1-2-二进制计数器递增" class="headerlink" title="例1.2: 二进制计数器递增"></a>例1.2: 二进制计数器递增</h4><p>对于一个 $k$ 位初始位 0 的二进制数,我们使用 $INCREMENT$ 算法每次对这个二进制数加一.伪代码如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">i = 0</span><br><span class="line">   while i &lt; A.length and A[i] == 1</span><br><span class="line">       A[i] = 0</span><br><span class="line">       i = i+1</span><br><span class="line">   if i &lt; A.length</span><br><span class="line">       A[i] = 1</span><br></pre></td></tr></table></figure>

<p>显然对于连续 $k$ 个 1 的二进制数的单次操作复杂度为 $O(k)$ .但整体复杂度却不为 $O(nk)$ ,因为每一次不可能都为连续的 1, 事实上对于第 $i$ 位来说一共被操作 $\lfloor{\frac{n}{2^i}}\rfloor$ 次,所以总均摊复杂度为:</p>
<p>$$\sum \limits_{i&#x3D;0}^{k-1} \lfloor{\frac{n}{2^i}}\rfloor &lt; n\sum \limits_{i&#x3D;0}^{\infty} \lfloor{\frac{1}{2^i}}\rfloor &#x3D; 2n$$</p>
<p>因此总均摊复杂度为 $O(n)$</p>
<h3 id="核操作"><a href="#核操作" class="headerlink" title="核操作"></a>核操作</h3><p>我们对所有的操作赋予不同的费用,一些可能会大于或小于实际费用.这个费用我们称作 <strong>摊还代价</strong>.</p>
<p>当摊还代价大于实际代价时,我们将多出的差价称作信用存储起来.后续当摊还代价小于实际代价时,我们用存储的信用偿还.</p>
<h4 id="例2-1-栈操作"><a href="#例2-1-栈操作" class="headerlink" title="例2.1 栈操作"></a>例2.1 栈操作</h4><table>
<thead>
<tr>
<th>操作</th>
<th>实际费用</th>
<th>摊还代价</th>
</tr>
</thead>
<tbody><tr>
<td><code>push</code></td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td><code>pop</code></td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td><code>multipop</code></td>
<td>$\min(s,k)$</td>
<td>0</td>
</tr>
</tbody></table>
<p>在每次 <code>push</code> 中,我们能存入一点信用.而 <code>pop</code> 和 <code>multipop</code> 的次数显然不能超出栈中的元素数量,因此我们可以保证 <strong>任何时刻信用价值非负</strong></p>
<p>显然可以看出总均摊复杂度为 $O(n)$</p>
<h4 id="例2-2-二进制计数器递增"><a href="#例2-2-二进制计数器递增" class="headerlink" title="例2.2 二进制计数器递增"></a>例2.2 二进制计数器递增</h4><p>我们将 0 变为 1 的置位操作赋予 2 摊还代价,1 变为 0 的复位操作赋予 0 摊还代价.</p>
<p>由于每次会保证只有 1 次置位操作,而复位操作都可以用先前的信用偿还,因此可以保证 <strong>任何时候信用价值非负</strong></p>
<p>因此总均摊复杂度为 $O(n)$</p>
<h3 id="势能法"><a href="#势能法" class="headerlink" title="势能法"></a>势能法</h3><p>与核算法不同,势能法将预付代价描述为 <strong>势能</strong>, 释放势能可以支付未来的代价, 将势能与整个数据结构相联系而不是特定对象.</p>
<p>我们设第 $i$ 次操作的费用为 $c_i$ ,设第 $i$ 次操作后的数据状态为 $D_i$  ,初始状态为 $D_0$, 设摊还代价为 $c_i^{\prime}$ ,我们选取一个从数据结构的状态映射到势的函数 $F$ ,我们需要保证对于任意 $i$ , $F(D_i) \geq F(D_0)$ .</p>
<p>令 $c_i^{\prime} &#x3D; c_i + F(D[i]) - F(D[i-1])$ ,显然 $\sum \limits_{i&#x3D;1}^{n} c_i^{\prime} &#x3D; \sum \limits_{i&#x3D;1}^{n} c_i + F(D_n) - F(D_0)$ , 由于 $F(D_n) \geq F(D_0)$ ,所以 $\sum c_i^{\prime} \geq \sum c_i$ ,则 $\sum c_i^{\prime}$ 为总摊还复杂度的上界</p>
<h4 id="例3-1-栈操作"><a href="#例3-1-栈操作" class="headerlink" title="例3.1 栈操作"></a>例3.1 栈操作</h4><p>我们选取栈中元素个数为势能函数 $F$ .</p>
<p>对于 <code>push</code> 操作, 实际代价为 1, 势差为1, 摊还代价为2;</p>
<p>对于 <code>pop</code> 操作, 实际代价为1, 势差为-1, 摊还代价为0;</p>
<p>对于 <code>multipop</code> 操作, 实际代价为 $\min(s,k)$ ,势差同样为 $\min(s,k)$ ,摊还代价为0</p>
<p>因此总均摊复杂度为 $O(n)$</p>
<h4 id="例3-2-二进制计数器递增"><a href="#例3-2-二进制计数器递增" class="headerlink" title="例3.2 二进制计数器递增"></a>例3.2 二进制计数器递增</h4><p>我们设 1 的个数为势能函数 $F$</p>
<p>每次操作实际代价为 $k$, 势差为 $2-k$, 摊还代价为 $2$</p>
<p>则总摊还复杂度为 $O(n)$</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
</search>
